# How we boosted response time of a service 2.5x using a simple singleton

This is a story of a hard debugging process and an easy solution for a problem that we were facing at WeTransfer.

A few weeks ago, we started rolling out to production our new storage manager, Storm.

As we increased the rollout percentage, we noticed a problem that was affecting its performance.

Storm is written in Ruby and uses AWS gems to interact with S3 and SQS.

It's worth saying that I'm an experienced Ruby engineer but not so familiar with the AWS ecosystem.

## The problem

The problem started when we noticed on Appsginal, some HTTP requests to the AWS metadata endpoint taking so long to complete:

![image1](../debug-aws-assets/image1.png)

This endpoint always runs in this specific IP (169.254.169.254) because it runs on an internal AWS container.

If I had seen this issue alone, I would have taken much more time to understand which dependency makes these requests because
as we can see, Appsignal does not show the origin of the request. By the way, we asked them this feature!

Thanks to the engineers who have experience with AWS at WeTransfer, I saved some time with that, and I learned that the AWS gem uses this endpoint to get credentials to interact with AWS services.

There are more details about how it works on the [AWS website](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html).

So, my first goal was to understand how the AWS gem managed credentials and when it
made these requests.

## Understanding how the AWS gem works

Storm has many AWS gems on its `Gemfile.lock`. I wanted to find out where these requests were made.

I started using a simple `grep` command in the staging console as follows:

```
~/storm $ bundle info aws-sdk-core
  * aws-sdk-core (3.114.0)
  Path: /usr/local/bundle/gems/aws-sdk-core-3.114.0

~/storm $ grep -r 169.254.169.254 /usr/local/bundle/gems/

/usr/local/bundle/gems/aws-sdk-core-3.114.0/lib/aws-sdk-core/instance_profile_credentials.rb:    # @option options [String] :ip_address ('169.254.169.254')
/usr/local/bundle/gems/aws-sdk-core-3.114.0/lib/aws-sdk-core/instance_profile_credentials.rb:      @ip_address = options[:ip_address] || '169.254.169.254'
/usr/local/bundle/gems/aws-sdk-core-3.114.0/lib/aws-sdk-core/ec2_metadata.rb:    # @option options [String] :endpoint (169.254.169.254) The IMDS endpoint.
/usr/local/bundle/gems/aws-sdk-core-3.114.0/lib/aws-sdk-core/ec2_metadata.rb:      @endpoint = options[:endpoint] || '169.254.169.254'
```

Note: I ran `grep` in staging because there are only Storm dependencies (gems) installed in this container. If I had grepped it on my laptop, it would have searched in gems that I use in other projects too.

So, I found a file to start the investigation: `aws-sdk-core/instance_profile_credentials.rb`.

First, I added a `raise '----here----'` in the method [open_connection](https://github.com/aws/aws-sdk-ruby/blob/5e9d68f8c9dd59ebd43585ece8cd01e0a4c90b79/gems/aws-sdk-core/lib/aws-sdk-core/instance_profile_credentials.rb#L155) that makes the HTTP request:

```ruby
def open_connection
  raise '----here----'
  http = Net::HTTP.new(@ip_address, @port, nil)
  #...
```

My goas was to find a test scenario that I could run and debug it locally.

So, I ran the tests expecting at least one to fail, but it didn't happen.

Note1: I used the RSpec's option `--fail-fast` to abort the execution in the first failure.

Note2: To change the gem's code, I opened it in my text editor with the command `bundle open aws-sdk-core`.

Note3: I recommend running [bundle pristine](https://bundler.io/v1.15/man/bundle-pristine.1.html) after modifying gems code to restore their original files after these experiments.

After that, there were 2 possibilities:
- no tests were covering this path
- the class `InstanceProfileCredentials` was being used only in production

Then, I started to search where this class was referenced inside the `aws-sdk-core` gem and I found it in the file [lib/aws-sdk-core/credential_provider_chain.rb](https://github.com/aws/aws-sdk-ruby/blob/7c730a81508981ec379920e04af60776fef69386/gems/aws-sdk-core/lib/aws-sdk-core/credential_provider_chain.rb#L166):

```ruby
def instance_profile_credentials(options)
  if ENV['AWS_CONTAINER_CREDENTIALS_RELATIVE_URI']
    ECSCredentials.new(options)
  else
    InstanceProfileCredentials.new(options)   # <------ here
  end
end
```

So, I added a `raise` there and ran the tests again, but nothing.

```ruby
def instance_profile_credentials(options)
  raise 'aaaaaaaaaaa'
  if ENV['AWS_CONTAINER_CREDENTIALS_RELATIVE_URI']
    ECSCredentials.new(options)
  else
    InstanceProfileCredentials.new(options)   # <------ here
  end
end
```

Then, I continued going up in the stack trace, trying to find a point where I could start debugging it on my laptop.

Luckily, I found a point in the next interaction, in the method [providers](https://github.com/aws/aws-sdk-ruby/blob/7c730a81508981ec379920e04af60776fef69386/gems/aws-sdk-core/lib/aws-sdk-core/credential_provider_chain.rb#L21):

```ruby
def providers
  raise 'aaaaaaaaaaa'
  [
    [:static_credentials, {}],
    [:static_profile_assume_role_web_identity_credentials, {}],
    [:static_profile_sso_credentials, {}],
    #...
    [:instance_profile_credentials, {
      retries: @config ? @config.instance_profile_credentials_retries : 0,
      http_open_timeout: @config ? @config.instance_profile_credentials_timeout : 1,
      http_read_timeout: @config ? @config.instance_profile_credentials_timeout : 1
    }]
  ]
end
```

At this point, I was able to add a breakpoint (`binding.pry`), run the test that has failed, and debug it.

I'm a fan of [pry-byebug](https://github.com/deivid-rodriguez/pry-byebug) gem beucase it's possible to use commands such as `up`, `down`, `step`, `next` and `finish` to debug the code. So, I used it. I strongly reccomend learning these commands.

After adding the breakpoint, I ran the failing test and used the command `up` to navigate in the stack trace to find which method was calling the method `providers`, so I found the method [resolve](https://github.com/aws/aws-sdk-ruby/blob/5e9d68f8c9dd59ebd43585ece8cd01e0a4c90b79/gems/aws-sdk-core/lib/aws-sdk-core/credential_provider_chain.rb#L11).

```ruby
def resolve
  providers.each do |method_name, options|
    provider = send(method_name, options.merge(config: @config))
    return provider if provider && provider.set?
  end
  nil
end
```

Using the `up` command is **much easier** than trying to find a method reference with a text search.

So, I could understand that this method `resolve` checked which credential provider was configured for the current environment, and for the `test` environment, it was using the `AssumeRoleCredentials` one.

This provider is used when we set AWS environment variables like `AWS_PROFILE` or `AWS_ACCESS_KEY_ID` and `AWS_SECRET_KEY`.

## First idea to resolve

After learning that, I asked myself why can't we use static credentials, by setting those environment variables in production, as we use in the test environment.

Then my teammates explained me that reason, which is also described on [AWS docs](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html):

> it's challenging to securely distribute credentials to each instance, especially those that AWS creates on your behalf, such as Spot Instances or instances in Auto Scaling groups. You must also be able to update the credentials on each instance when you rotate your AWS credentials

So, my first idea was dropped.

## Back to the investigation

My next goal was to find which line of our code was starting this execution until reaching the method `resolve`.

Then, I used the `backtrace` command (from `pry-byebug`) and searched for `storm`:

![backtrace](../debug-aws-assets/image3.jpg)

Note: Thanks [iTerm2](https://iterm2.com/) for having this text search with highlight! I was a Linux user in the past, and there was no such feature in Linux consoles.

I found this line in Storm:

```ruby
s3_signer = WT::S3Signer.for_s3_bucket(bucket, expires_in: expires_in)
```

Which was calling [this line](https://github.com/WeTransfer/wt_s3_signer/blob/v0.1.0/lib/wt_s3_signer.rb#L38) inside the gem wt_s3_signer:

```ruby
client = Aws::S3::Client.new
#...
credentials = client.config.credentials
```

Then I thoght... "hmm, every time that a new client is instantiated, it needs to fetch credentials again. This might be the reason for all those HTTP requests!"

We expected AWS gems to cache credentials in some way because they expire only after some time.

So, I started to investigate how the `aws-sdk-core` gem caches it and I found the module `RefreshingCredentials` which defines the method [credentials](https://github.com/aws/aws-sdk-ruby/blob/ad78938ea707482a04c22b56758c101f8e9a42db/gems/aws-sdk-core/lib/aws-sdk-core/refreshing_credentials.rb#L26-L29):

```ruby
def credentials
  refresh_if_near_expiration
  @credentials
end
```

This method is pretty clear. It refreshes the credentias, when necessary, and returns it.

When it's not necessary to refresh it, it only returns `@credential`.

So this confirmed my theory! Given `@credentials` is cached in the instance, if we instantiate new client objects, it will fetch new credentials.

Then, I started search on [AWS docs](https://docs.aws.amazon.com/sdk-for-ruby/v3/developer-guide/setup-config.html) if they mention something about that. It would helped me a lot if I had found something like this:

> We recommend using a singleton instance for our clients otherwise, credentials will not be cached/reused and your application will spend more time getting new credentials every time.

# How to prove my theory

To prove that my thoery was right, I needed to execute these methods and confirm that the HTTP requests were made only for fresh client instances.

It was not possible to reproduce it in my laptop, because as I showed before, the authentication mechanism is different.

So I used the staging server to debug it.

I would prefer debugging it on my laptop to use `pry-byebug`, but in this case I used another stragegy.

This is when Ruby metaprogramming helped!

I created the following [monkey patch](https://www.justinweiss.com/articles/3-ways-to-monkey-patch-without-making-a-mess/) to print some logs inside the AWS gem:

```ruby
module Aws::RefreshingCredentialsMetrics
  def refresh
    puts "------------refresh"
    super
  end

  def refresh!
    puts "------------refresh!"
    super
  end

  private

  def http_put(*args)
    puts "--------------- http_put"
    super(*args)
  end

  def http_get(*args)
    puts "--------------- http_get"
    super(*args)
  end
end

class Aws::InstanceProfileCredentials
  prepend Aws::RefreshingCredentialsMetrics
end

Aws::S3::Client.new.config.credentials
```

I pasted that in the staging application's console and got the following result:

```
------------refresh
--------------- http_put
--------------- http_get
--------------- http_get
=> #<Aws::InstanceProfileCredentials:0x000055fa19d78f20...
```

Then, I tried to call `credentials` with the same client:

```ruby
client = Aws::S3::Client.new
------------refresh
--------------- http_put
--------------- http_get
--------------- http_get
client.config.credentials
=> #<Aws::InstanceProfileCredentials:0x000055fa1a21f880...
client.config.credentials
=> #<Aws::InstanceProfileCredentials:0x000055fa1a21f880
```

It didn't make the HTTP requests again, as I suspected.

I also noticed that these objects had a expiration date:

```ruby
client.config.credentials.expiration
=> 2021-04-25 19:25:47 UTC
```

So, it seemed safe to use the cached credentials!

## We had a plan!

At this point, my plan was to change the gem wt_s3_signer to not create an instance of `Aws::S3::Client` on each call to [WT::S3Signer.for_s3_bucket](https://github.com/WeTransfer/wt_s3_signer/blob/v0.1.0/lib/wt_s3_signer.rb#L31).

But, when I opened the PR, the team mentioned that maybe we should use a [connection pool](https://github.com/mperham/connection_pool) because we were not sure if the AWS gems were thread-safe.

We found [this issue](https://github.com/aws/aws-sdk-ruby/issues/748#issuecomment-85621503) confirming that the gem `aws-sdk-core` was thread-safe. We assumed that the other gems (S3 and SQS) followed the same pattern and we chose to use a singleton for the clients.

## First step to fix the problem

To complete

I did or more exper
TODO:
- falar do release da gem injetando o client

## TODO: achei em outros lugares

```
bucket = Aws::S3::Bucket.new(@bucket_name)
bucket.object
```

And [this line](https://github.com/WeTransfer/sqewer/blob/49a85115b160781a545a8b482001179475dfe37c/lib/sqewer/connection.rb#L58) in the gem sqewer:

```ruby
client = Aws::SQS::Client.new
client.receive_message
```
